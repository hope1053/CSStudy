## ✔️ 객체지향이란?

- 현실 세계의 개체를 속성과 메소드가 결합된 형태의 객체로 표현하는 개념

## 📚 객체지향 등장 배경

1. 순차적, 비구조적 프로그래밍
    1. 필요한게 있으면 순서대로 추가해가며 구현하는 방식
    2. 직관적이지만 `goto` 문의 무분별한 활용으로 인해 코드의 흐름을 파악하기 매우 어려워짐
2. 절차적, 구조적 프로그래밍
    1. 반복될 가능성이 있는 것들을 재사용이 가능한 함수로 만들어 사용하는 프로그래밍 방식
    2. 너무 추상적이라는 단점
    3. 예를 들어 도서 관리 프로그램의 경우, 책에 해당하는 자료형, 책과 관련된 함수를 구현해야함
    4. 하지만 구조적인 프로그램에서는 이 둘이 논리적으로 함께 할 수 없는 구조
3. 객체지향 프로그래밍
    1. 특정한 개념의 함수와 자료형을 함께 묶어서 관리하기 위해 탄생
    2. 객체 내부에 자료형(필드)와 함수(메소드)가 같이 존재함
    3. 이를 통해 해당하는 책의 제목, 저자, 페이지와 같은 자료형 + 읽기, 예약하기 등의 메소드를 ‘책'이라는 객체에 한번에 묶어서 저장하는 것이 가능
    4. 객체 간의 독립성이 생기고 중복코드의 양이 줄어든다는 장점, 유지보수에도 도움

## 📂 객체지향 구성 요소

- 클래스(Class)
    - 같은 종류의 집단에 속한 속성과 행위를 정의하고 있는 틀
    - 클래스에 속한 각각의 객체를 인스턴스라고 함
- 객체(Object)
    - 필요한 자료 구조(Attribute)와 이에 수행되는 함수(Method)들을 가진 하나의 소프트웨어 모듈
- 어트리뷰트(Attribute)
    - 객체 안에 존재하는 절대적 자료형
    - 데이터, 속성, 상태, 변수, 상수, 자료구조
- 메서드(Method)
    - 객체가 갖는 어트리뷰트를 처리하는 알고리즘
    - 객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산을 정의한 것
- 메시지(Message)
    - Sender와 Receiver 객체들간의 상호작용의 수단으로 다른 객체에 특정 작업을 요청하는 신호
    - 구성 요소
        - 메시지를 받는 객체의 이름
        - 객체가 수행할 메소드 이름
        - 메소드를 수행할 때 필요한 인자

## 💡 객체지향 장점

- 규모가 큰 대형 프로젝트에 적합
- 소프트웨어의 재사용률, 확장성, 유지보수 향상

## 🔥 객체지향 단점

- 설계가 어려움
- 규모가 커서 실행속도 저하

## ✔️ 객체지향 특징

- 캡슐화
    - 데이터와 데이터를 처리하는 함수를 하나로 묶는 것
    - 캡슐화 특성을 통해 낮은 **결합도**를 유지하도록 설계할 수 있음 + 클래스 내부 구현의 응집도는 높여야함
    - 결합도(coupling): 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가
        - 결합도가 낮아야하는 이유는? 객체들 간의 의존도가 높아지면 굳이 객체지향으로 설계하는 의미가 없음
        - 낮은 결합도 = 외부에서 접근할 필요가 없는 것은 private으로 접근하지 못하도록 제한을 두는 것(정보은닉)
- 정보 은닉
    - 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것
    - 각 객체의 수정이 다른 객체에게 주는 영향을 최소화하는 기술
- 추상화
    - 세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어내는 것
    
    > 아우디, BMW, 벤츠는 모두 ‘자동차’라는 공통점이 있음
    자동차라는 추상화 집합을 만들어두고 자동차들이 가진 공통적인 특징들을 만들어서 활용
    > 
- 상속
    - 상위 클래스가 갖는 속성과 연산을 그대로 물려받는 것
    - 하위 클래스는 상속을 통해 상위 클래스의 속성, 메서드를 다시 정의하지않아도 자신의 속성으로 활용 가능
- 다형성
    - 한 메시지가 객체에 따라 다른 방법으로 응답할 수 있는 것
    - 상속과 함께 활용할 때 큰 힘을 발휘
    - 부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 활용하는 것

## ⛏ 객체지향 설계 원칙

### SOLID

- SRP(Single Responsibility) : 단일 책임 원칙
    - 클래스는 단 한 개의 책임을 가져야한다.
- OCP(Open-Closed) : 개방-폐쇄 원칙
    - 높은 응집도와 낮은 결합도
    - 1) 확장에는 열려 있어야 하고, 2) 변경에는 닫혀있어야 한다.
        - 1) 모듈의 확장성을 보장하는 것, 새로운 변경사항이 발생했을 때 유연하게 코드를 추가 또는 수정할 수 있기 때문
        - 2) 객체를  직접 수정하지 않고도 변경사항을 적용할 수 있도록 설계해야함
    - 기능을 변경하거나 확장할 수 있으면서 그 기능을 사용하는 코드는 수정하지 않아야한다
- LSP(Liskov Substitution) : 리스코프 치환 원칙
    - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상 동작해야한다 (자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있따)
    - 상속 관계가 아닌 클래스들을 상속 관계로 설정하면 이 원칙이 위배됨
- ISP(Interface Segregation) : 인터페이스 분리 원칙
    - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야함 → 범용 인터페이스 하나보다는 특정 클라이언트를 위한 여러 개의 인터페이스 분리가 더 좋음!
        - `운전자가 자동차를 운전한다.` 라는 명제를 객체간 관계로 비유하면 자동차에 대한 인터페이스, 운전자에 대한 인터페이스 각각 분리
        - 운전자: 택시기사, 우버 드라이버
        - 자동차: 버스, 택시, 스포츠카
        - 확장성이 커짐
    - 각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 한다.
- DIP(Dependency Inversion) : 의존 역전 원칙
    - 자신보다 쉽게 변하는 것에 의존하지 않는다.
    - 구체적인 것이 추상화된 것에 의존해야하며 그 반대가 되어선 안된다.
    - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
    - 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
    - 즉, 저수준 모듈이 변경돼도 고수준 모듈은 변경할 필요가 없는 것이다.