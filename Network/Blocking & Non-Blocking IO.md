# Blocking & Non-Blocking I/O
### **Blocking I/O Model이란**

- cpu의 기본적인 I/O 모델로 리눅스에서 모든 소켓 통신은 기본 `blocking`으로 동작한다.
- **I/O 작업이 진행되는 동안 유저 프로세스는 *자신의 작업을 중단한 채 대기하는 방식*이다.**

![https://blog.kakaocdn.net/dn/Nq3bZ/btqP11QIQS9/QyBQSJqCaNA2XxiMFiAmm1/img.png](https://blog.kakaocdn.net/dn/Nq3bZ/btqP11QIQS9/QyBQSJqCaNA2XxiMFiAmm1/img.png)

### **Blocking I/O**

1. 유저는 커널에게 read 작업 요청

2. 데이터가 입력될 때까지 대기

3. 데이터가 입력되면 커널이 유저에게 결과를 전달

- ex. 카카오톡이 사용자가 메시지를 전송할 때까지 대기하고 있는 것

### **Non-Blocking Model 이란**

- I/O 작업이 진행되는 동안 ***유저 프로세스의 작업을 중단시키지 않는 방식***이다.

![https://blog.kakaocdn.net/dn/C9O8h/btqQgzx8RrB/zmPFd9WupeU0LKKQaZCxpk/img.png](https://blog.kakaocdn.net/dn/C9O8h/btqQgzx8RrB/zmPFd9WupeU0LKKQaZCxpk/img.png)

### **NonBlocking I/O 작업 순서**

1. 유저가 커널에게 read 작업 요청

2. 데이터가 입력됐든 안됬는 요청하는 그 순간, 바로 결과가 반환된다. 

- (데이터가 없다면 없다는 결과 메시지 `EWOULDBLOCK`) 반환

3. 입력 데이터가 있다면 1-2번 반복. 

- 2번에서 결과 메시지를 받은 유저는 다른 작업을 진행한다.

4. 입력 데이터가 있다면 커널이 유저에게 결과 전달한다.

- 이 경우 I/O의 진행시간과 관계없이 애플리케이션에서 작업을 오랜 시간 중지하지 않고 I/O 작업을 진행할 수 있다.
- 하지만 반복적으로 시스템 호출이 발생하기에 이역시 자원 낭비가 된다.  데이터를 입력할 때만 전송하는 게 아니라 주기적으로 계속 반복한다.
- "너 보낸 메시지 있어?" -> "없구나!" -> '잠시 이 사용자한테 공지 좀 보내야지!' -> "너 보낸 메시지 있어?"(반복)
- Non-Blocking 문제인 `반복적 시스템 콜 호출`을 해결하기 위해 **I/O 이벤트 통지 모델**이 도입되었다.이벤트란 **수신 버퍼**나 **출력 버퍼**에 데이터를 처리하는 동작을 의미한다.

> 수신 버퍼의 이벤트 -> 입력 버퍼에 데이터가 수신되었다는 것을 알림 출력 출력 버퍼의 이벤트 -> 출력 버퍼가 비었으니 데이터 전송이 가능한 상황을 알림
> 
- 카톡을 예시로 들면 non-blocking 방식 일시 "너 보낸 메시지 있어?"를 계속 물어봐야 한다. 하지만 이벤트 통지방식 사용 시 먼저 입력 버퍼에서 "사용자가 보낸 메시지가 있습니다"라고 **알림(이벤트 통지 모델)**을 준다면 계속 물어봐야 했던 그 시간을 카카오톡은 이제 효율적으로 사용할 수 있다. 의존성이 없어진다.
- I/O 이벤트 통지방식에는 동기/비동기 모델로 분류 가능하다.I/O 작업 상황(결과) 반환 방식에 따라 동기, 비동기 방식으로 분류된다.
