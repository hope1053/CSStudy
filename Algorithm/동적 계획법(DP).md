## **동적 계획법 (Dynamic Programming)**

> 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법
> 

흔히 말하는 DP가 바로 '동적 계획법'

**한 가지 문제**에 대해서, **단 한 번만 풀도록** 만들어주는 알고리즘이다.

즉, 똑같은 연산을 반복하지 않도록 만들어준다. 

실행 시간을 줄이기 위해 많이 이용되는 수학적 접근 방식의 알고리즘

### **접근 방식**

- 커다란 문제를 쉽게 해결하기 위해 작게 쪼개서 해결하는 방법인 분할 정복과 매우 유사하다.
- 하지만 간단한 문제로 만드는 과정에서 중복 여부에 대한 차이점이 존재한다.

즉, 동적 계획법은 간단한 작은 문제들 속에서 '계속 반복되는 연산'을 활용하여 빠르게 풀 수 있는 것이 핵심이다.

### DP의 두가지 방법

- Tabulation (bottom up)
- Memoization (top down)

### 1) Tabulation (bottom up)

- Tabulation이란 도표, 도표를 작성 - 의 뜻.

예- 를 들어 `factorial(n)`을 구하는 과정에 적용된 Tabulation 방식의 DP를 살펴보면..

```
// factorial은 n까지의 수를 모두 곱한 것 이므로,
// factorial(n) = factorial(n-1) * n 으로 계산이 가능하다

// 따라서 i부터 n까지 '작은 값 에서부터 차례로 (= tabulation)' 팩토리얼 값들을 구하고,
// 재사용 해 나가며 factorial(n)을 구할 수 있다.

const DP = [];

DP[0] = 1;

for (let i = 1; i < n; i++) {
    DP[i] = DP[i-1] * i;
}
```

- 설명하자면 n이 9로 주어지고 DP[9] 를 구하기 위해서는 DP[0], DP[1], DP[2] ... DP[9]의 순서대로 차근차근 값을 구하고
- 구한 값을 토대로 (그에 대한 중복된 계산을 하지 않고) 다음 값을 빠르게 구해나가는 bottom - up 형태를 취한다.

### 2) Memoization

다음으로 Memoization은 top-down 방식이라 하였음으로 결과값`factorial(n)`에 대한 접근을 먼저 시도하지 않을까 유추해 볼 수 있다.

```
const DP = [];

function solve (x) {
    if (x == 0) {
        return 1;
    }

    // 값이 DP에 존재한다면 사용한다.
    if (DP[x] !== undefined) {
        return DP[x];
    }

    // 값이 DP에 존재하지 않는다면 구하고, 메모한다.
    return DP[x] = x * solve(x-1); // top-down
}
```

Tabulation 방식과 달리 먼저 결과값에 접근하려는 시도를 하고, 해당 값에 가까운 값을 DP에서 찾아나가며 탑다운의 형태로 중복된 값을 사용하거나 메모하는 형태를 띈다.

예를 들어, 팩토리얼 9를 구하기 위해 `solve(9)` 가 호출되었을 때 DP[0] 에서 차근차근 DP[9]까지 구해나가는 Tabulation과 달리 DP[9] 에서 부터 접근하여 DP[8], ... DP[1] 의 값들을 확인하고 재귀적인 호출 과정을 거친 이후 최종적인 값을 구할 수 있게 된다.
