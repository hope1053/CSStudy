## 정의

가장 긴 증가하는 부분 수열

ex. [7, 2, 3, 8, 4, 5]에서 LIS는 [2, 3, 4, 5]

## 구현

```python
arr = [7, 2, 3, 8, 4, 5]
# dp는 arr[i]를 마지막 원소로 가질 때 가장 긴 증가하는 부분 수열의 길이
# 생성 시 모든 값을 1로 초기화
dp = [1 for i in range(len(arr))]

for i in range(len(arr)):
    for j in range(i):
				# 현재 위치(i)보다 이전에 있는 원소(j)가 작은지 확인(크거나 같으면 증가하는 부분수열이 아니기 때문에)
				# 작다면 i보다 이전 위치의 숫자들 중 dp최댓값을 구하고 1을 더하면 됨
        if arr[i] > arr[j]:
            dp[i] = max(dp[i], dp[j]+1)

print(max(dp))
```

| arr | 7 | 2 | 3 | 8 | 4 | 5 |
| --- | --- | --- | --- | --- | --- | --- |
| dp | 1 | 1 | 1 | 1 | 1 | 1 |

| arr | 7 | 2 | 3 | 8 | 4 | 5 |
| --- | --- | --- | --- | --- | --- | --- |
| dp | 1 | 1 | 2 | 1 | 1 | 1 |

| arr | 7 | 2 | 3 | 8 | 4 | 5 |
| --- | --- | --- | --- | --- | --- | --- |
| dp | 1 | 1 | 2 | 3 | 1 | 1 |

| arr | 7 | 2 | 3 | 8 | 4 | 5 |
| --- | --- | --- | --- | --- | --- | --- |
| dp | 1 | 1 | 2 | 3 | 3 | 4 |

## 시간 복잡도

O(n^2)