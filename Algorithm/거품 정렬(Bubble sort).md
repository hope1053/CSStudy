# 거품 정렬(Bubble sort)

### Bubble sort란?

Bubble Sort는 Selection Sort와 유사한 알고리즘으로 **`서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘`**입니다.

이름의 유래로는 정렬 과정에서 원소가 이동하는 모습이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어졌다고 합니다.

## **Process (Ascending)**

1. 1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 세 번째 원소와 네 번째 원소를, … 이런 식으로 (마지막-1)번째 원소와 마지막 원소를 비교하여 조건에 맞지 않는다면 서로 교환합니다.
- {3, 7, 6, 4, 2, 1} ⇒ N-1번 비교
- {3, 6, 7, 4, 2, 1}
- {3, 6, 4, 7, 2, 1}
- {3, 6, 4, 2, 7, 1}
- {3, 6, 4, 2, 1, 7}
1. 1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외됩니다.
2. 2회전을 수행하고 나면 끝에서 두 번째 원소까지는 정렬에서 제외됩니다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어납니다.

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    vector<int> array = {3, 7, 6, 4, 2, 1};
    int N = array.size();

    for (int i = 0; i < N - 1; i++)
    {
        // 옆에 있는 수를 비교하여 큰 수를 뒤로보내기
        for (int j = 0; j < N - 1 - i; j++)
        {
            if (array[j] > array[j + 1])
            {
                int temp = array[j]; // swap
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
    // 출력 : 1 2 3 4 6 7
    for (auto n : array)
        cout << n << ' ';
    return 0;
}
```

### **시간복잡도**

버블정렬은 항상 일정하게 다음의 연산 횟수를 갖습니다.

N-1 + N-2 + … + 2 + 1 = N(N-1)/2

따라서 시간복잡도는 O(N^2)이 됩니다.

## **공간복잡도**

주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 **O(n)** 입니다.

## **장점**

- 구현이 매우 간단하고, 소스코드가 직관적입니다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않습니다. => 제자리 정렬(in-place sorting)

## **단점**

- 시간복잡도가 최악, 최선, 평균 모두 O(n^2)으로, 굉장히 비효율적입니다.
- 정렬 돼있지 않은 원소가 정렬 됐을때의 자리로 가기 위해서, 교환 연산(swap)이 많이 일어나게 됩니다.
