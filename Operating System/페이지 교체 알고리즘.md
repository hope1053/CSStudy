# 페이지 교체 알고리즘

### 페이지 교체 알고리즘(page-replacement), 언제 사용될까?

<img src="https://user-images.githubusercontent.com/71035113/156919026-5592dd5d-8643-4fc6-91a4-8f34fa8d23d4.png" width="600">

<img src="https://user-images.githubusercontent.com/71035113/156919028-f2bc5ac2-3953-450a-99d5-f35f562d7d76.png" width="600">

- 프로세스가 특정 페이지를 요구할 때 해당 페이지를 physical memory에 로딩해야한다.
- 메모리에 필요한 페이지가 올라와 있을 때는 잘 진행되지만
- 올라와 있지 않은 경우에는 프로세스가 필요로 하는 페이지가 없으므로 (`page-fault`) 하드 디스크에서 페이지를 찾아 빈 프레임에 로딩해야 한다. (오른쪽 그림)

⇒ 여기서 다시, 페이지를 올릴 빈 프레임이 없는 문제가 발생할 수 있다. 

- 이때 사용하는 것이 새로 올릴 페이지와 교체될 프레임(`victim`)을 찾는 알고리즘인 페이지 교체 알고리즘이다.

### ****FIFO(first in first out)****

- 가장 간단한 알고리즘으로, 메모리에 올라온 지 **가장 오래된** 페이지를 교체한다.
- 이 알고리즘을 수행하기 위해서 **각 페이지가 올라온 시간을 페이지에 기록**
하거나, **페이지가 올라온 순서를 큐(Queue)에 저장**하는 방식 등을 사용할 수 있다.

메모리가 3개의 프레임으로 나눠져 있는 경우를 예시로 들겠습니다.

![Untitled (97)](https://user-images.githubusercontent.com/71035113/156919029-7d42800a-c742-4394-95a6-ac441395e7d9.png)
### 장점

- 이해가 쉽고, 구현이 간단하다.

### 단점

- 하지만 항상 성능이 좋다고 장담할 수 없다.
- **페이지 7의 경우**에는 프로세스 초기에 쓰인 후 한동안 쓰이지 않기 때문에 FIFO교체 방식이 큰 문제를 일으키지 않는다.
- **페이지 2(9번째)의 경우,** 직전 페이지 부재(page 4)로 인해 페이지 4와 페이지 2가 교체되고 난 후, 또 다시 페이지 2를 사용하기 위해 교체했던 페이지 2를 다시 불러들였다.

<aside>
💡 따라서, 활발하게 사용 중인 페이지를 계속해서 교체한다면 페이지 부재율이 높아지고 실행속도가 떨어질 수 있다.

</aside>

### 최적 페이지 교체 알고리즘

앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 알고리즘이다.

- 최적 알고리즘은 수행하기 전에 선행되어야 할 전제조건이 있다.
- **프로세스가 앞으로 사용할 페이지를 미리 알아야 한다**는 것이다.
- 이 전제 조건이 실제 활용에서는 알 방법이 없기 때문에 최적 알고리즘은 **구현이 불가능한 알고리즘** 이다.
- 때문에 이 알고리즘은 실제 구현 목적보다 다른 알고리즘과 비교 **연구 목적**을 위해 주로 사용된다.

2가 들어갈 차례에서 7이 가장 나중에 사용되므로 7 → 2로 교체함

![Untitled (98)](https://user-images.githubusercontent.com/71035113/156919030-66e575ae-5175-4b82-9989-0f7c58806e7a.png)

### 장점

최적 교체 알고리즘은 가장 오랫동안 사용되지 않을 페이지를 이미 알고 교체하기 때문에 모든 페이지 교체 알고리즘을 통틀어 **가장 페이지 교체 수가 적다.**

- **페이지 7의 경우,** 18번째에 가서나 다시 쓰일 것을 미리 알고 있기 때문에 페이지 2와 페이지 7을 교체했다.
- **페이지 1의 경우(page3, 6번째 참조),** 현재 올라와있는 {2, 0, 1} 중 페이지 1이 14번째 참조로 가장 뒤에 쓰일 것을 알기 때문에 페이지 1과 페이지 3을 교체했다.

### **LRU(least-recently-used)**

- **가장 오래 사용되지 않은** 페이지를 교체하는 알고리즘이다.
- 최적 알고리즘은 실제 구현이 불가능하므로, **최적 알고리즘의 방식과 비슷한 효과를 낼 수 있는 방법**을 사용한 것이 **LRU 알고리즘**이다.
- 최적 알고리즘은 **페이지가 사용될 시간**을 미리 알고 있다.
- 미리 아는 것이 불가능하다면, **과거의 데이터를 바탕으로 페이지가 사용될 시간을 예측하여 교체하는 것**은 가능하다.
- 예측 방법으로 **가장 오랜 기간 사용되지 않은(least recently used)** 페이지를 교체하는 방식을 사용하는 것이다.

11번째 0이 들어갈 때, 4, 3, 2이 올라와 있던 상태고 앞에서 4가 가장 적게 사용됐기 때문에 4와 0을 교체한다.

![Untitled (99)](https://user-images.githubusercontent.com/71035113/156919032-6cda6eba-d7ad-4154-b397-f5b664e4dd1c.png)

LRU 알고리즘은 최적 알고리즘보다 페이지 교체 횟수가 높지만 FIFO 알고리즘 보다 효율적이다.

- **페이지 2의 경우(9번째),** 직전의 페이지 부재(page 4) 에서 *(페이지 2가 바로 다음에 사용될 것을 모르기 때문에)* {2, 0, 3} 중 가장 오랫동안 사용되지 않았던 페이지 2를 교체한다.
- **페이지 0의 경우(11번째),** 가장 오랫동안 사용되지 않았던 페이지 4를 페이지 0과 교체한다. 실제로 페이지 4는 이후에 해당 프로세스에서 참조되는 일이 없다.

<aside>
💡 LRU 알고리즘은 많은 운영체제가 채택하는 알고리즘이며, 좋은 알고리즘이라고 평가 받고있다.

</aside>

: 백준 멀티탭 스케쥴링 문제랑 비슷한듯,, 다시 풀어보기

### 레퍼런스

- [페이지 교체(page-replacement) 알고리즘. 요구 페이징 시스템은 프로세스가 특정 페이지를 요구할 때 해당 페이지를… | by YE Ryu | POCS | Medium](https://medium.com/pocs/%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-page-replacement-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-650d58ae266b)
