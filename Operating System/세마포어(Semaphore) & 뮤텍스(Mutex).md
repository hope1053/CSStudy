## ✔️ 세마포어 & 뮤텍스

- 여러 프로세스가 공유 자원에 접근하는 것을 제어하기 위한 방법, Race Condition이 발생하지 않도록 하는 방법
- **병행 처리를 위한 프로세스 동기화 기법**

## 👏 세마포어(Semaphore)

- 옛날에 기찻길 신호등 역할을 하던 깃발 = semaphore
- 기찻길이 겹친 경우, 겹친 부분을 critical section이라고 볼 수 있고 semaphore를 사용하여 해당 부분을 지나가도 되는지 안되는지 알려주는 개념
- **공유된 자원의 데이터 혹은 Critical section에 여러 프로세스(혹은 스레드)가 접근하는 것을 막아줌)
→ 동기화 대상이 하나 이상**
- 공유 자원의 갯수, 단순히 정수 값을 가진 변수라고 생각하면 됨. 현재 사용할 수 있는 자원의 개수

### 📚 binary semaphore

- 0 또는 1의 값만 갖는 세마포어
- if 두 개의 기찻길이 겹쳐있는 상태, 기찻길이 비어있음 → semaphore = 1
왜냐하면 해당 길에는 하나의 기차만 지나갈 수 있기 때문에
- if 하나의 기차가 지나가고 있다면 → Semaphore = 0
- 뮤텍스와 비슷한 형태로 작동

### 📚 counting semaphore

- 도메인의 제한이 없는 세마포어
- 서버에 다섯개의 프린터가 연결돼있는 경우, semaphore = 5
- 사용자가 하나하나씩 사용하는 경우 semaphore는 점점 감소하다가 0이됨

### 📚 세마포어 접근 함수

- wait(): 세마포어 값을 감소시킴. 값이 음수가 되면 wait()을 호출한 프로세스는 블록됨.
- signal(): 세마포어 값을 증가시킴. 값이 양수가 아니면 wait()연산에 의해 블록된 프로세스들을 깨움

```swift
struct semaphore {
	int count;
    	queueType queue;
};

void semWait (semaphore s) {
	s.count--;
    if (s.count < 0) {
    	/* 이 구역으로 들어왔다는 것은 현재 프로세스(혹은 쓰레드)가 공유 자원에 접근할 수 없다는 것을 의미*/
    	/* 요청한 프로세스를 s.queue에 연결 */
        /* 요청한 프로세스를 블록 상태로 전이 시킴*/
    }
} 

void semSignal (semaphore s) {
	s.count++;
    if (s.count <= 0) {
    	/* count가 0보다 작거나 같다는 것은 대기하고 있는 프로세스(또는 스레드)가 존재한다는 것을 의미*/
        /* s.queue에 연결되어 있는 프로세스를 큐에서 제거 */
        /* 프로세스의 상태를 실행 가능으로 전이시키고 ready list에 연결 */
    }
}
```

## 👏 뮤텍스(Mutex)

- 공유된 자원의 데이터 혹은 Critical section에 하나의 프로세스가 접근하는 것을 막아줌
→ 동기화 대상이 하나
- 임계 영역에 들어갈 때 `lock`을 걸어서 다른 프로세스가 접근하지 못하도록 함
- 임계 영역에서 나오면 해당 락을 `unlock`함
- lock을 걸었던 프로세스만이 Unlock할 수 있다는 점이 세마포어와는 다름(세마포어는 wait을 하지 않은 프로세스도 signal이 가능)

```swift
mutex = 1;

void lock () {
	while (mutex != 1) {
    	/* mutex 값이 1이 될 때까지 기다립니다.*/
    }
    /* 이 구역에 도착했다는 것은 mutex 값이 1이라는 것입니다.
       따라서 이제 뮤텍스 값을 0으로 만들어 다른 프로세스(혹은 쓰레드)가 접근하지 못하도록 막아야 합니다.
    */
    mutex = 0;
}

void unlock() {
	/* 임계 구역에서 나온 프로세스는 다른 프로세스가 접근할 수 있도록 락을 해제합니다.*/
	mutex = 1;
}
```
