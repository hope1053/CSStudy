## ✔️ CPU 스케줄링이란?

하나의 프로세스가 끝나면 CPU는 다음 프로세스 작업을 수행해야한다. 

이때 다음 프로세스로 어떤 프로세스를 선택할 것 인지 정하는 알고리즘을 `CPU 스케줄링 알고리즘`이라고 한다.

→ 이때 알고리즘을 어떻게 짰는지에 따라 **CPU의 자원을 얼마나 효율적으로 사용하게 되는지** 결정됨

## ❓ CPU 스케줄링은 왜 필요할까?

- 컴퓨터를 사용하면서 동시에 많은 프로그램을 실행함
- CPU는 사실상 한 번에 하나의 프로세스만 실행할 수 있음
- 동시에 프로세스들을 처리하는 것처럼 보이게 하기 위해서 각 프로세스에 얼마나 많은 자원, 얼마나 긴 시간동안 할당해야하는지 결정해야함

## 🚩 CPU 스케줄링이 추구하는 바

**공평성** : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 특정 프로세스가 배제되어서는 안 된다.

**효율성** : 시스템 자원을 놀리는 시간 없이 스케줄링해야 한다.

**안정성** : 우선순위를 사용하여 중요한 프로세스가 먼저 처리되도록 해야 한다.

**반응 시간 보장** : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.

**무한 연기 방지** : 특정 프로세스의 작업이 무한히 연기되어서는 안 된다.

## 👩‍💻 스케줄링 알고리즘

### 📚 비선점 스케줄링

어떤 프로세스가 CPU를 점유하고 있다면 해당 프로세스 작업이 완료될 때까지 다른 프로세스는 CPU를 사용할 수 없음

- 프로세스가 CPU를 놓아주는 시점까지 스케줄링이 일어나지 않음
- 프로세스 일괄 처리에 적합하고 Context Switching을 최소화할 수 있다는 장점이 있음
- 긴급히 처리되어야 할 프로세스가 처리되지 못할 수 있다는 단점이 있음

ㄴ 📂 **FCFS(First Come First Service)**

![Untitled](https://user-images.githubusercontent.com/22907483/157024246-8dafddec-a141-455c-8d6d-0751bc476b4c.png)

- 프로세스가 Ready Queue에 도착한 순서대로 CPU에 할당하는 방식
- 작업 완료 시간을 예측하기 용이함
- 콘보이 이펙트(Convoy Effect): CPU 처리 시간이 길지만 덜 중요한 작업을 처리하느라 CPU 처리 시간이 짧고 더 중요한 작업을 기다리게 할 수 있음

ㄴ 📂 **SJF(Shortest Job First)**

![Untitled](https://user-images.githubusercontent.com/22907483/157024269-cc494343-92b4-4a44-a11e-5ca6805d9868.png)

- CPU 처리 시간이 짧은 순서대로 CPU에 할당
- 모든 방식을 통틀어 평균 대기 시간을 가장 짧게 만드는 방식
- 기아 상태(Starvation): CPU 처리 시간이 긴 프로세스는 계속 뒤로 밀려나기 때문에 무한정 기다려야하는 상황

ㄴ 📂 **HRN(Highest Response Ratio Next)**

- 기아 상태를 해결하기 위해 고안된 방식
- 우선처리순위를 CPU 처리 시간 + Ready Queue에서 대기한 시간까지 고려하여 결정(Aging 기법)

> (대기 시간 + CPU 처리 시간) / CPU 처리 시간
> 
- 해당 알고리즘이 선점 방식으로 스케줄링 될 경우에는 Context Switching이 너무 자주 발생 → 비선점으로 활용

ㄴ 📂 **우선순위(Priority)**

- 대기중인 프로세스들에게 우선순위를 부여하여 우선순위가 높은 순서대로 처리함
- 선점 스케줄링 방식으로도 활용 가능
- 기아 상태가 발생할 수 있는 문제 → 이를 해결하기위해 에이징 기법 사용
- 대기 시간이 길어질 수록 우선순위가 올라가기 때문에 계속 기다리지 않아도됨

ㄴ 📂 **그래서 무엇을 가장 자주 사용하나요?**

- 장단점을 따져보았을 때 FCFS 알고리즘을 사용할 이유가 전혀 없어보이지만 현실에서 SJF, HRN을 자주 사용하지 못하는 이유가 있음
- 실제로 프로세스마다 CPU 처리 시간이 얼마나 걸릴지 알 수 있는 방법이 없기 때문에

### 📚 선점 스케줄링

어떤 프로세스가 CPU를 점유하고 있을 때 우선순위가 높은 다른 프로세스가 점유를 빼앗아 CPU를 점유할 수 있음

- 프로세스의 I/O 요청, I/O 응답, Interrupt 발생, 작업 완료 등의 특별한 상황에서 스케줄링이 발생
- 긴급히 처리되어야할 프로세스를 처리할 수 있다는 장점
- 비선점 스케줄링에 비해 Context Switching이 자주 일어날 수 있다는 단점

ㄴ 📂 **SRT(Shortest Remaining Time)**

- SJF 방식을 선점 스케줄링 방식으로 변경한 기법
- 동일하게 CPU 처리 시간이 짧은 순서대로 CPU에 할당
- 하지만 선점 스케줄링 방식이기 때문에 현재 점유중인 프로세스보다 처리 시간이 더 짧은 프로세스가 Ready Queue에 들어오면 새로 들어온 프로세스가 기존 프로세스의 CPU 점유를 빼앗을 수 있음

ㄴ 📂 **우선순위(Priority)**

ㄴ 📂 **라운드로빈(Round-Robin)**

- 도착하는 순서대로 처리하는 FCFS 스케줄링 방식에 선점 스케줄링 + Time Quantum 개념을 추가한 방식
- Time Quantum: 각 프로세스마다 CPU를 연속적으로 사용할 수 있는 제한 시간
- 지정된 Time Quantum만큼의 시간이 지나면 프로세스로부터 CPU 자원을 회수하고 Ready Queue 가장 뒤로 보냄
- 따라서 Time Quantum을 얼마로 둘 지 결정하는 것이 매우 중요함
- 너무 길면, CPU 처리 시간이 긴 프로세스가 CPU를 오래 점유하여 다른 프로세스들이 계속 기다려야함 → Convoy Effect 발생할 수 있음
- 너무 짧으면, Context Switching이 너무 자주 발생 → 오버헤드 커짐

ㄴ 📂 **다단계 큐(Multi-Level Queue)**

- 프로세스를 그룹으로 나누고 그룹마다 Queue를 두는 방식 = Ready Queue를 여러 개로 나누어 사용하는 방식
- 각 Queue마다 서로 다른 스케줄링 방식을 적용할 수 있다는 것이 특징
- Foreground Queue & Background Queue
    - 사용자와 직접 상호작용하는 프로세스와 백그라운드에서 돌아가는 프로세스의 중요도를 다르게 분류
    - 전자는 빠르게 처리, 후자는 덜 빠르게 처리되어도 괜찮다고 판단함
    - 따라서 전자에는 응답시간을 줄이기 위해서 라운드로빈 스케줄링 방식을 적용, 후자에는 응답시간이 큰 의미가 없기 때문에 FCFS 방식을 적용하는 등 각 Queue마다 적절하다고 판단되는 방식 적용
- 여러 개의 Queue를 사용하기 때문에 어떤 Queue에 얼마나 CPU를 오래 할당할지 결정하는 스케줄링 필요
    - 고정 우선순위(Fixed Priority)
        - Queue마다 우선순위를 두는 방식
        - 사용자가 직접 원하는 프로세스에 CPU 자원을 우선 할당하기 때문에 기아상태가 발생할 수 있음
    - 타임 슬라이스(Time Slice)
        - 기아 상태를 예방하고자 생긴 스케줄링 방식
        - Time Slice를 두고 해당 시간 비율에 따라 각각의 Queue를 서비스함
        - ex. CPU 자원의 75% → Foreground Queue, 25% → Bacgkround Queue

ㄴ 📂 **다단계 피드백 큐(Multi-Level Feedback Queue)**

- 다단계 큐 스케줄링 방식 + 에이징 기법
- 프로세스가 다른 큐로 이동하는 것이 가능함
- 우선순위가 낮은 큐에서 오래 기다린 프로세스의 우선순위를 점점 올려서 우선순위가 높은 큐로 옮겨주는 방식
