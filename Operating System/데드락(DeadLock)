## ✔️ 데드락이란?

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a9d593c-bad9-4362-aca5-64e05cd3676a/Untitled.png)

- 교착 상태
- 둘 이상의 프로세스가 서로 다른 프로세스가 점유하고 있는 자원을 얻고 싶어서 기다릴 때 무한 대기에 빠지는 상황
- 멀티 프로그래밍 환경에서 한정된 자원을 사용하려고 서로 경쟁하는 상황에서 발생

## 👩‍💻 데드락 발생 조건

아래 4가지 조건이 동시에 성립해야함

- **상호 배제(Mutual Exclusion)**
    - 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다.
    - 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때 까지 기다려야한다.
- **점유 대기(Hold and Wait)**
    - 1) 자원을 최소한 하나 보유하고(점유) 2) 다른 프로세스에 할당된 자원을 점유하기 위해 대기(대기)하는 프로세스가 존재해야 한다.
- **비선점(Non Preemptive)**
    - 이미 할당된 자원은 사용이 끝날 때까지 강제로 뺏을 수 없다.
- **순환 대기(Circular Wait)**
    - 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야한다.
    - 프로세스 집합 {p0, p1, ... , pn}이 있을 때 p0은 p1이 점유한 자원을 대기하고 p1은 p2가 점유한 자원을 대기하고 pn은 p0이 점유한 자원을 요구해야함

## 👩‍💻 데드락 해결법

- 데드락이 발생하지 않도록 **예방하기**
- 데드락 발생 가능성을 인정하면서도 적절하게 **회피하기**
- 데드락 발생을 허용하지만 데드락을 **탐지**하여 데드락에서 **회복하기**

## 💡 데드락 예방

데드락 발생조건 4가지 중 하나라도 발생하지 않게 하는 것이 예방법

- **상호 배제 방지**
    - 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 함
    - 예를 들어 파일에 접근하는데 있어서 다수의 읽기 접근은 허용, 쓰기 접근은 한 시점에 하나만 배타적으로 허용
    - 추후 동기화 관련 문제가 발생할 수 있음
- **점유 대기 방지**
    - 자원을 점유하지 않고 있을 때만 다른 자원을 요청할 수 있도록 함
    - 프로세스가 실행되기 전 필요한 모든 자원을 할당받게 하거나, 자원이 필요한 경우 보유하고 있는 자원을 모두 반납하고 이전 자원 + 필요한 자원을 다시 요청하고 기다리는 방식
    
    > 1. 프로세스는 모든 자원을 할당받기 위해 오랜 기간 기다릴 수 있다.
    실제로는 프로세스가 일부 자원만 할당받고 수행을 시작할 수 있으며, 이후 다른 자원은 수행 중에 할당받아도 되는 경우가 있다.
    하지만 이 방법을 적용하면 프로세스는 모든 자원의 할당이 가능해질 때까지 대기해야 한다.
    
    2. 한꺼번에 할당받은 자원 중 일부는 실제 수행이 끝날 때쯤에 사용될 수 있다. 그렇다면 그 자원들은 프로세스의 시작 시점과 실제 사용 시점 사이에서 실제로 이용되지 않으면서 점유되어 있다는 의미가 된다. 그 동안 다른 프로세스들은 그 자원을 사용할 수 없다.
    
    3. 프로세스가 미래에 사용될 모든 자원을 미리 알기는 상당히 어렵다.
    > 
- **비선점 방지**
    - 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 함
- **순환 대기 방지**
    - 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만(ex.프로세스 순서의 증가 방향) 자원을 요구할 수 있도록 함

→ 이렇게 조건을 방지해서 데드락을 예방하는 방법은 **시스템의 처리량이나 효율성을 떨어트리는 단점**이 발생할 수 있음

## 💡 데드락 회피

데드락이 발생하기 전에 데드락을 예상하여 **safe state**일때만 자원 요청을 허용하는 방법 → 데드락이 발생할 가능성이 있으면 아예 자원을 할당하지 않음!

- safe sequence(안전 순서)
    - 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서를 찾을 수 있는 상황
- safe state(안정 상태)
    - 프로세스들이 요청하는 모든 자원을 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해줄 수 있는 상태
    - safe sequence가 존재하여 모든 프로세스가 정상적으로 종료할 수 있는 상태
- unsafe state(불안정 상태)
    - 데드락 발생 **가능성**이 있는 상황
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a6e39e3a-27fa-46eb-a01d-a83d64d5ec18/Untitled.png)
        
    - 데드락이 불안정 상태의 부분집합

### 회피 알고리즘 : **은행원 알고리즘(Banker’s Algorithm)**

- 자원을 할당한 후에도 시스템이 항상 safe state에 있을 수 있도록 하자!
- 다익스트라가 제안
- 어떤 자원의 할당을 허용할지 말지 결정하기 전에 **미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션해서 safe state를 유지할 수 있는지** 여부를 검사하는 알고리즘 (자원 할당 거부 알고리즘)
- 현재 자원의 가용 개수와 프로세스의 자원 요구량을 미리 알고 있어야 가능함

| 프로세스 | Max(최대) | Allocation(현재) | Need(필요) |
| --- | --- | --- | --- |
| P0 | 10 | 5 | 5 |
| P1 | 4 | 2 | 2 |
| P2 | 9 | 2 | 7 |
- 시스템이 총 12개의 자원을 가지고 있는 상태
- 현재 프로세스에 할당된 자원은 5 + 2 + 2 = 9, 남은 자원의 양은 3
- 여기서 가능한 safe sequence는?
    - `P1`은 2개가 이미 할당되어 있고, 2개를 추가적으로 할당받기를(`Need`) 기다리고 있음.
    현재 Available 자원은 3개이므로, 이 중에 2개를 P1에게 할당해줌.
    ⇒ 현재 Available은 3 - 2 = 1개
    - 실행이 끝난 `P1`은 자신에게 할당되어 있던 자원 4개를 모두 반납
    ⇒ 현재 Available은 1 + 4 = 5개
    - 현재 Available 자원이 5개이고, 이를 **P0에게 모두 할당해 주면** P0도 실행 가능해짐.
    ⇒ 현재 Available은 5 - 5 = 0개
    - 실행이 끝난 `P0`은 자신에게 할당되어 있던 자원 10개를 모두 반납
    ⇒ 현재 Available은 0 + 10 = 10개
    - 마지막으로 `P2`에게 자원 7개를 할당
    ⇒ 현재 Available은 10 - 7 = 3개
    - 실행이 끝난 `P2`는 자신에게 할당되어 있던 자원 9개를 모두 반납
    ⇒ 현재 Available은 3 + 9 = 12개
- if 처음에 `P2` 가 3개의 자원을 할당받고 있었다면?
    - Available 자원은 2개였을 것이고 그렇다면 P1에게 2개를 할당하고 총 4개를 반납
    ⇒ Available 자원 4개
    - P0, P2 모두 필요한 자원이 4개 이상이기 때문에 할당받기를 계속 기다렸어야함
    → **데드락 발생**
- 이런 경우에는 운영체제가 P2가 자원을 하나 더 요청했을 때 바로 할당하지 않고 P1이 끝날때까지 기다린 후 할당하는 등 은행원 알고리즘을 활용해서 자원 할당량을 사전에 파악하고 데드락을 회피해야함!
- 하지만 미리 최대 자원 요구량을 알아야하고, 할당할 수 있는 자원 수가 일정해야 하는 등 사용에 있어 제약 조건이 많음, 그에 따른 자원 이용도 하락

## 💡 데드락 탐지 및 회복

### 🔥 탐지 기법

- Allocation, Request, Available 등으로 데드락 발생 여부를 탐지
→ 현재 시스템의 자원 할당 상태를 가지고 파악
- **자원 할당 그래프(Resource Allocation Graph)**를 통해서도 탐지 가능
- 자원을 요청할 때마다 탐지 알고리즘을 실행하면 오버헤드가 발생한다는 단점

### 🔥 회복 기법

- 데드락을 탐지했다면 순환 대기에서 벗어나 데드락으로부터 회복하기 위한 방법을 사용
- 프로세스 1개 이상 중단시키기
    - **교착 상태에 빠진 모든 프로세스를 중단시키는 방법**
        - 계속 연산중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기될 수 있는 부작용이 발생할 수 있음
    - **데드락이 해결될 때 까지 한 번에 한 프로세스씩 종료시키는 방법**
        - 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있음
- 자원 선점하기
    - 프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해 주는 방법

## 👩‍💻 데드락 무시

- 데드락이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않는 방식
- 사실 데드락은 매우 드물게 발생하기 때문에 이러한 조치를 취하는 것 자체가 더 큰 오버헤드 일 수 있음
- 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 프로세스를 죽이는 등의 방법으로 대처함
→ UNIX, Window 등 대부분의 범용 운영체제가 채택하는 방식
