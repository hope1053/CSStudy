### 인터럽트, 왜 필요할까?

- 그 이유는 입출력 연산이 CPU 명령 수행속도보다 현저히 느리기 때문이다.
- 운영체제를 악덕 사장님, CPU를 비싼 월급 주고 데려온 고오급 인력이라고 생각해보자.
- 악덕 사장 입장에서는 비싼돈 들여온 만큼 고오급 인력이 쉬지않고 일해서 돈값을 했으면 좋겠다고 생각할 것이다.

![https://hiphapis.files.wordpress.com/2014/03/screen-shot-2014-03-18-at-4-49-54-pm.png?w=250](https://hiphapis.files.wordpress.com/2014/03/screen-shot-2014-03-18-at-4-49-54-pm.png?w=250)

> 내 피같은 돈! 뽕을 뽑아먹겠어! (고용노동부 국번없이 1350)
> 
- 그런데 아주 오래걸리는 입출력 연산을 CPU가 매번 기다린다면(월급루팡 한다면)...?
- 비싼 돈 주고 모셔온 CPU를 백분 활용하지 못해 운영체제 사장님은 환장할 지경.
- CPU가 입출력 처리를 기다리며 쉬는 꼴을 못보는 사장님은 연산 결과가 나올 때 까지 다른 일을 시킨다. 우리 직원 뽕을 뽑아야하니까!그리고 입출력 직원에게 자신의 업무가 완료되면 그때 CPU선배님에게 작업 완료를 알리라고 일러둔다.
- CPU가 다시 해당 작업도 이어서 할 수 있도록 한다.
- 여기서 입출력 직원이 CPU선배님에게 작업 완료를 알려주는 것이 `인터럽트`이다!

## **인터럽트(Interrupt)**

- CPU가 프로그램을 실행하고 있을 때, 입출력 장치나 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다.
- 인터럽트는 크게 `하드웨어 인터럽트`와 `소프트웨어 인터럽트`로 나뉜다.

### 하드웨어 인터럽트

- 하드웨어가 발생시키는 인터럽트
- 하드웨어 장치가 cpu에 어떤 사실을 알려주거나 cpu 서비스를 요청해야 할 경우 발생시킴

### 소프트웨어 인터럽트

- 소프트웨어가 발생시키는 인터럽트
- 소프트웨어(사용자 프로그램)가 스스로 인터럽트 라인을 세팅한다.
- 종류: 예외 상황, system call

인터럽트를 발생시키기 위해 하드웨어/소프트웨어는 cpu내에 있는 인터럽트 라인을 세팅해서 인터럽트를 발생시킴

cpu는 매번 명령을 수행하기 전에 인터럽트라인이 세팅되어있는지를 검사한다.

## 인터럽트 과정

process A 실행 중 디스크에서 어떤 데이터를 읽어오라는 명령을 받았다고 가정해보자.

- process A는 `system call`을 통해 인터럽트를 발생시킨다.
- CPU는 현재 진행 중인 기계어 코드를 완료한다.
- 현재까지 수행중이었던 상태를 해당 process의 **`PCB(Process Control Block)`**에 저장한다. (수행중이던 MEMORY주소, 레지스터 값, 하드웨어 상태 등...)
- `PC(Program Counter, IP)`에 다음에 실행할 명령의 주소를 저장한다.
- CPU내의 인터럽트 벡터를 읽고 ISR 주소값을 얻어 **ISR(Interrupt Service Routine)**로 점프하여 루틴을 실행한다.
- 해당 코드를 실행한다.
- 해당 일을 다 처리하면, 대피시킨 레지스터를 복원한다.
- ISR의 끝에 IRET 명령어에 의해 인터럽트가 해제 된다.
- IRET 명령어가 실행되면, 대피시킨 PC 값을 복원하여 이전 실행 위치로 복원한다.

## 인터럽트와 특권 명령

### 명령어의 종류

CPU가 수행하는 명령에는 `일반 명령`과 `특권 명령`이 있다.

- **일반 명령**은 메모리에서 자료를 읽어오고, CPU에서 계산을 하는 등의 명령이고 모든 프로그램이 수행할 수 있는 명령임
- **특권 명령**은 **보안이 필요한 명령**으로 **입출력 장치, 타이머 등의 장치를 접근하는 명령**이다. 특권 명령은 항상 `운영체제`만이 수행할 수 있다.

### kernel mode vs user mode

운영체제는 하드웨어적인 보안을 유지하기 위해 기본적으로 두가지 operation을 지원한다. 

- **kernel mode**는 운영체제가 CPU의 제어권을 가지고 명령을 수행하는 모드로 `일반 명령`과 `특권 명령` 모두 수행할 수 있다.
- 하지만 **user mode**는 일반 사용자 프로그램이 CPU제어권을 가지고 명령을 수행하는 모드이기 때문에 `일반 명령`만을 수행할 수 있다.

### 과정을 살펴보자

ex. 위의 process A가 프로그램 명령 수행중에 디스크 입출력 명령을 읽은 경우를 생각해 보자. 

- 사용자 프로그램은 입출력 장치에 접근하는 명령을 수행할 수 없다. user mode에서 특권 명령을 수행할 수 없기 때문이다.
- 이런 경우에 사용자 프로그램은 운영체제에게 `시스템 콜`을 통해 특권명령을 대신 수행해달라고 요청한다. 시스템 콜은 주소 공간 자체가 다른 곳(커널의 code영역)으로 이동해야 하므로 **프로그램이 인터럽트 라인에 인터럽트를 세팅**하는 명령을 통해 이루어진다.

> 시스템 콜은 커널 영역의 기능을 사용자 모드가 사용 가능하게, 즉 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해준다.
> 
- CPU가 인터럽트 라인을 검사하고 인터럽트가 발생한 것을 감지하게 된다.
- 현재 수행중인 사용자 프로그램을 잠시 멈추고 CPU의 제어권을 운영체제에게 양도한다. (kernel mode)
- 그리고 이 때 하드웨어적으로 `모드 비트`가 1에서 0으로 자동으로 세팅되어 특권 명령을 수행할 수 있게 된다.

![https://media.vlpt.us/post-images/adam2/77e17e20-2fc9-11ea-a15f-818085aba1cd/image.png](https://media.vlpt.us/post-images/adam2/77e17e20-2fc9-11ea-a15f-818085aba1cd/image.png)
