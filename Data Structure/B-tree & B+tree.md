# **B Tree & B+ Tree**

## **B Tree & B+ Tree**

![Untitled (68)](https://user-images.githubusercontent.com/71035113/152135218-3216be1c-fdd6-434b-9fcf-7077687a342a.png)

> 이진 트리는 하나의 부모가 두 개의 자식밖에 가지질 못하고, 균형이 맞지 않으면 검색 효율이 선형검색 급으로 떨어진다. 하지만 이진 트리 구조의 간결함과 균형만 맞다면 검색, 삽입, 삭제 모두 O(logN)의 성능을 보이는 장점이 있기 때문에 계속 개선시키기 위한 노력이 이루어지고 있다.
> 

### **B Tree**

---

- BST에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 밸런스를 맞추는 트리
- BST처럼 정렬된 상태 보장해서 BST와 비슷하지만 한 노드당 자식 노드가 2개 이상 가능함
- key값을 이용해서 찾고자 하는 데이터를 트리 구조를 이용해서 찾음
    - 검색할 때는 루트노드에서 시작해서 하향식으로 검색함
    - 루트 노드에서 시작하여 **key들을 순회**하면서 검사합니다.
    - 만일 *k*와 같은 key를 찾았다면 검색을 종료합니다.
    - 검색하는 값과 key들의 **대소관계를 비교**해봅니다. 어떠한 key들 사이에 *k*가 들어간다면 해당 key들 사이의 자식노드로로 내려갑니다.
    - 해당 과정을 **리프노드에 도달할 때까지 반복**합니다. 만일 리프노드에도 *k*와 같은 key가 없다면 검색을 실패합니다.
- 실제 데이터베이스에서는 B트리에서 발전한 B+트리를 사용함

### B-tree는 균형트리

![Untitled (69)](https://user-images.githubusercontent.com/71035113/152135222-6b9ea43f-0a3b-48d9-9fe6-a4fd3fed0b34.png)

- 균형트리란 루프로부터 리프까지의 거리가 일정한 트리구조로 성능이 안정화 되어 있음
- 그러나, B-tree 처음 생성 당시는 균형 트리이지만 테이블 갱신(INSERT/UPDATE/DELETE)의 반복을 통해 서서히 균형이 깨지고, 성능도 악화된다.

### 왜 B-tree는 빠를까

- 균형트리니까, 항상 좌, 우 자식노드 개수의 `밸런스`를 유지하므로 최악의 경우에도 무조건 탐색 시간이 O(logN)을 가지게 된다.

```cpp
대량의 데이터를 처리해야 할 때, 하나의 노드에 많은 데이터를 가질 수 있다는 점은 상당히 큰 장점이다. 

왜냐하면 대량의 데이터는 메모리보다 블럭 단위로 입출력하는 하드디스크 or SSD에 저장해야하기 때문!

ex) 한 블럭이 1024 바이트면, 2바이트를 읽으나 1024바이트를 읽으나 똑같은 입출력 비용 발생. 

따라서 하나의 노드를 모두 1024바이트로 꽉 채워서 조절할 수 있으면 입출력에 있어서 효율적인 구성을 갖출 수 있다.

→ B-Tree는 이러한 장점을 토대로 많은 데이터베이스 시스템의 인덱스 저장 방법으로 애용하고 있음
```

### **B+ Tree: `B-Tree + 연결리스트`**

---

![Untitled (70)](https://user-images.githubusercontent.com/71035113/152135224-d81c46d9-956e-467a-959c-169e4c84393c.png)

B-tree의 확장 개념으로 B-tree의 경우에 내부 노드에 key와 data를 담을 수 있었다. 

하지만 B+tree는 데이터의 빠른 접근을 위해서 내부 노드에 key만 담아두고 data는 담지 않는다. 

오직 리프 노드에만 key와 data를 저장하고 리프 노드끼리 `Linked list`로 연결되어 있다. 

### **장점**

1. 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 많이 확보할 수 있어서 더 많은 key들을 수용할 수 있음. 
2. 하나의 노드에 더 많은 key들을 담을 수 있어서 트리의 높이는 더 낮아지므로 검색시간과 디스크에 접근하는 횟수가 줄어듦 ⇒ cache hit을 높일 수 있음 
3. 풀 스캔 시, B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되므로 B-tree에 비해 빠르다. B-tree의 경우에는 모든 노드를 확인해야 한다.

### **단점**

B-tree의 경우 best case에서는 루트에서 끝날 수 있지만, B+tree는 무조건 leaf 노드까지 내려가봐야 함


### **참고자료**

- [[MySQL] B-tree, B+tree란? (인덱스와 연관지어서) :: Carry On Progamming (tistory.com)](https://zorba91.tistory.com/293)
