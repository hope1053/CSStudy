## Isolation Level

- 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지
- 특정 트랜잭션이 다른 트랜잭션이 변경한 데이터를 볼 수 있도록 허용할지 말지 결정하는 것
- 데이터베이스에서는 트랜잭션이 독립적인 수행을 할 수 있도록 Locking을 통해 특정 트랜잭션이 DB를 수정하는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요함
- 무조건 다 Lock을 걸어서 순서대로 트랜잭션을 처리하면 성능이 떨어지고 그렇다고 Locking의 범위를 잘못 줄이면 잘못된 값이 처리될 수 있음
⇒ 효율적인 Locking이 필요함

> Lock 트랜잭션 처리의 순차성을 보장하기 위한 방법
- 공유(Shared) lock: 데이터를 읽을 때 사용되는 lock, 공유락끼리는 동시 접근 가능, 공유락이 설정된 데이터에는 베타락 사용 불가
- 베타(Exclusive) lock: 데이터를 변경하고자 할 때 사용, 트랜잭션이 완료될 때까지 유지, lock이 해제될때까지 다른 트랜잭션(읽기 포함)은 리소스에 접근 불가
> 

## Level

> Read Uncommitted
Read Committed
Repeatable Read
Serializable
> 

아래로 내려갈수록 트랜잭션간 고립정도가 높아지며 성능은 떨어짐(동시성, 데이터 무결성)

일반적인 온라인 서비스는 Read Committed, Repeatable Read 중 하나를 사용함

### Read Uncommitted

SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층

- 트랜잭션 처리중이거나 아직 commit되지 않은 데이터를 다른 트랜잭션이 읽을 수 있음
- `사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 아직 완료되지 않은(Uncommitted) 트랜잭션이지만 데이터B를 읽을 수 있다`
- 데이터베이스의 일관성을 유지하는 것이 불가능
- **Dirty Read**가 발생할 수 있음 + Non-Repeatable Read, Phantom Read
    - A 트랜잭션에서 사원의 나이를 27에서 28로 수정. 아직 commit 전
    - B 트랜잭션에서 사원 나이에 접근. 28로 조회 완료(Dirty Read)
    - 이후 A 트랜잭션에서 문제 발생해서 Roll back 함
    - 하지만 B 트랜잭션에서는 아직 28살이라고 생각하고 로직 수행 → 데이터 정합성에 문제 생김

### Read Committed

SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층

- 트랜잭션 실행되는 동안 다른 트랜잭션의 접근 불가, 대기해야함
- `사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 해당 데이터에 접근이 불가능함`
- Commit된(확정된) 트랜잭션만 조회 가능
- SQL서버의 Default level(대부분의 DBMS)
- **Non-Repeatable Read** 발생 +  Phantom Read
    - 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션이 값을 수정, 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상
    - B 트랜잭션에서 사원 나이 조회: 27
    - A 트랜잭션에서 27 →28로 변경하고 커밋
    - B 트랜잭션에서 조회: 28

### Repeatable Read

트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층

- 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함
- 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능
- Non-Repeatable Read 부정합이 발생하지 않음
    - 10번 트랜잭션이 500번 사원 조회
    - 12번 트랜잭션이 500원 사원 이름 변경하고 커밋
    - 10번 트랜잭션이 500번 사원 조회 → undo 영역에 백업된 데이터 반환
- Phantom Read 발생
    - 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
    - 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타남

### Serializable

트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층

- 가장 엄격한 격리 수준으로 완벽한 읽기 일관성 모드 제공
- 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능
- 동시처리 능력이 굉장히 떨어짐